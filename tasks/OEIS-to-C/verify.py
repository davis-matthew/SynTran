import subprocess
import re

def check_compilation(problem_name, thread_id, code):
    with open(f'temp_{problem_name}_{thread_id}.cpp', "w") as file:
        file.write(code)
    
    compile_output = subprocess.run(['g++', f'temp_{problem_name}_{thread_id}.cpp', '-o', f'temp_{problem_name}_executable_{thread_id}'],capture_output = True, text=True)
    if not compile_output.returncode == 0:
        return False, 'compilererror', compile_output.stderr
    return True, 'success', ''

def get_print_form(lst):
    return "[" + ", ".join(str(item) for item in lst) + "]"

def check_sequence(seq_values, runtime_values):
    int_max = 2_147_483_647 # 2^31 - 1
    long_max = 9_223_372_036_854_775_807 # 2^63 - 1

    # Match shorter seq to subsequences of longer
    longer = seq_values
    shorter = runtime_values
    if len(shorter) > len(longer):
        shorter, longer = longer, shorter

    for i in range(len(longer) - len(shorter) + 1):
        match_overall = True
        match_until_long_max = True
        match_until_int_max = True

        # FIXME: if sequence quickly goes past overflow values, this could be giving false positives
        for j in range(len(shorter)):
            if shorter[j] != longer[i + j]:
                match_overall = False
                if abs(shorter[j]) <= long_max or abs(longer[i + j]) <= long_max:
                    match_until_long_max = False
                if abs(shorter[j]) <= int_max or abs(longer[i + j]) <= int_max:
                    match_until_int_max = False
                break
                
        # FIXME: this offset is not necessarily in a useful direction cause we do shorter to longer instead of runtime to oeis or something
        if match_overall:
            return ("COMPLETE", i)
        if match_until_long_max:
            return ("UP_TO_LONG_MAX", i)
        if match_until_int_max:
            return ("UP_TO_INT_MAX", i)

    return ("NONE",-1)

def check_generated_code(problem_name, thread_id, seq_values, generated_code):
    with open(f'temp_{problem_name}_{thread_id}.cpp', "w") as file:
        file.write(generated_code)
    
    compile_output = subprocess.run(['g++', f'temp_{problem_name}_{thread_id}.cpp', '-o', f'temp_{problem_name}_executable_{thread_id}'],capture_output = True, text=True)
    
    try:
        runtime_output = subprocess.run([f'./temp_{problem_name}_executable_{thread_id}'], capture_output=True, text=True, timeout=120)
    except subprocess.TimeoutExpired:
        return False, 'terminate', 'Code took too long to verify'
    
    if not runtime_output.returncode == 0: # FIXME: doesn't print stderr?
        return False, 'runtimeerror', runtime_output.stderr
    
    runtime_values = [int(value.strip()) for value in runtime_output.stdout.splitlines() if value.strip().isnumeric()]
    if len(seq_values) == 0:
        return False, 'sequencemismatch', f'Your sequence did not properly return values. Make sure your code returns the following values that match the OEIS sequence: \n\t{get_print_form(seq_values)}'
    
    result, offset = check_sequence(seq_values, runtime_values)
    if result == 'COMPLETE':
        return True, 'success', f'Your sequence is fully accurate with an offset of {offset}.'
    if result == 'UP_TO_LONG_MAX':
        return True, 'success', f'Your sequence is accurate up to LONG_MAX with an offset of {offset}.'
    if result == 'UP_TO_INT_MAX':
        return True, 'success', f'Your sequence is accurate up to INT_MAX with an offset of {offset}.' 

    return False, 'sequencemismatch', f'The sequence generated by your code does not match the OEIS sequence. Your Values:\n\t{get_print_form(runtime_values)}\nSequence Values:\n\t{get_print_form(seq_values)}'

def verify_generation(state, lock, src_code, generation):
    matches = re.findall(r'```(?:\w+\n)?(.*?)```', generation, re.DOTALL)
    
    if len(matches) < 1:
        return False, 'missing_codeblock', 'Code block not present in generated translation. Make sure you provide the code block and surround it with ```.'

    return True, 'success', ''

def verify_syntax(state, lock, src_code, generation):
    matches = re.findall(r'```(?:\w+\n)?(.*?)```', generation, re.DOTALL)
    
    try:
        generated_function = matches[0].strip()
    except:
        return False, 'compilererror', 'unable to find codeblock'

    with open(state['src_file'], 'r') as file:
        lines = file.readlines()

    seq_values = []
    seq_name = lines[0].split(" ")[1]
    for line in lines[1:]:
        if line.startswith("%N"):
            break
        seq_values.extend([int(x) for x in line.split()[2].rstrip(',').split(',')])
    seq_length = len(seq_values)

    runner_code = '''#include <iostream>
    '''+ generated_function +'''

        int main() {
            for(int i = 0 ; i <''' +str(seq_length) + '''; i++){
                std::cout << '''+seq_name+'''(i) << "\\n";
            }
        }
        '''
    
    return check_compilation(state['problem_name'], state['thread_id'], runner_code)

def verify_semantics(state, lock, src_code, generation):
    with open(state['src_file'], 'r') as file:
        lines = file.readlines()

    seq_values = []
    seq_name = lines[0].split(" ")[1]
    for line in lines[1:]:
        if line.startswith("%N"):
            break
        seq_values.extend([int(x) for x in line.split()[2].rstrip(',').split(',')])
    seq_length = len(seq_values)
    
    matches = re.findall(r'```(?:\w+\n)?(.*?)```', generation, re.DOTALL)

    try:
        generated_function = matches[0].strip()
    except:
        return False, 'runtimeerror', 'missing codeblock'

    runner_code = '''#include <iostream>
    '''+ generated_function +'''

        int main() {
            for(int i = 0 ; i <''' +str(seq_length) + '''; i++){
                std::cout << '''+seq_name+'''(i) << "\\n";
            }
        }
        '''

    return check_generated_code(state['problem_name'], state['thread_id'], seq_values, runner_code)