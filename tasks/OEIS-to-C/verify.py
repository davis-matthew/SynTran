import subprocess
import re

def get_print_form(lst):
    return "[" + ", ".join(str(item) for item in lst) + "]"

def check_sequence(seq_values, runtime_values):
    int_max = 2_147_483_647 # 2^31 - 1
    long_max = 9_223_372_036_854_775_807 # 2^63 - 1

    # Match shorter seq to subsequences of longer
    longer = seq_values
    shorter = runtime_values
    if len(shorter) > len(longer):
        shorter, longer = longer, shorter

    for i in range(len(longer) - len(shorter) + 1):
        match_overall = True
        match_until_long_max = True
        match_until_int_max = True

        # FIXME: if sequence quickly goes past overflow values, this could be giving false positives
        for j in range(len(shorter)):
            if shorter[j] != longer[i + j]:
                match_overall = False
                if abs(shorter[j]) <= long_max or abs(longer[i + j]) <= long_max:
                    match_until_long_max = False
                if abs(shorter[j]) <= int_max or abs(longer[i + j]) <= int_max:
                    match_until_int_max = False
                break
                
        # FIXME: this offset is not necessarily in a useful direction cause we do shorter to longer instead of runtime to oeis or something
        if match_overall:
            return ("COMPLETE", i)
        if match_until_long_max:
            return ("UP_TO_LONG_MAX", i)
        if match_until_int_max:
            return ("UP_TO_INT_MAX", i)

    return ("NONE",-1)

def check_generated_code(thread_id, seq_values, generated_code):
    with open('temp_generated_code.cpp', "w") as file:
        file.write(generated_code)
    
    compile_output = subprocess.run(['g++', 'temp_generated_code.cpp', '-o', f'temp_executable_{thread_id}'],capture_output = True, text=True)
    if not compile_output.returncode == 0:
        print("\tcompiler error")
        return 'compilererror', compile_output.stderr
    
    try:
        runtime_output = subprocess.run([f'./temp_executable_{thread_id}'], capture_output=True, text=True, timeout=1000)
    except subprocess.TimeoutExpired:
        return 'terminate', 'Code took too long to verify'
    
    if not runtime_output.returncode == 0: # FIXME: doesn't print stderr?
        print("\truntime error")
        return 'runtimeerror', runtime_output.stderr
    
    runtime_values = [int(value.strip()) for value in runtime_output.stdout.splitlines() if value.strip().isnumeric()]
    
    result, offset = check_sequence(seq_values, runtime_values)
    if result == 'COMPLETE':
        print("\tsuccess - FULL")
        return 'success-FULL', f'Your sequence is accurate with an offset of {offset}.'
    if result == 'UP_TO_LONG_MAX':
        print("\tsuccess - LONG_MAX")
        return 'success-LONG_MAX', f'Your sequence is accurate up to LONG_MAX with an offset of {offset}.'
    if result == 'UP_TO_INT_MAX':
        print("\tsuccess - INT_MAX")
        return 'success-INT_MAX', f'Your sequence is accurate up to INT_MAX with an offset of {offset}.' 

    print("\tsequence mismatch")
    return 'sequencemismatch', f'The sequence generated by your code does not match the OEIS sequence. Your Values:\n\t{get_print_form(runtime_values)}\nSequence Values:\n\t{get_print_form(seq_values)}'

def verify(thread_id, lock, original_code_path, translated_code_path):
    with open(original_code_path, 'r') as file:
        lines = file.readlines()

    seq_values = []
    seq_name = lines[0].split(" ")[1]
    for line in lines[1:]:
        if line.startswith("%N"):
            break
        seq_values.extend([int(x) for x in line.split()[2].rstrip(',').split(',')])
    seq_length = len(seq_values)

    generation = ""
    with open(translated_code_path) as file:
        generation = file.read()
    
    matches = re.findall(r'```(?:\w+\n)?(.*?)```', generation, re.DOTALL)
    
    if len(matches) < 1:
        return 'invalidgeneration', 'Code block not present in generated translation. Make sure you provide the code block and surround it with ```.'

    generated_function = matches[0].strip()

    runner_code = '''#include <iostream>
    '''+ generated_function +'''

        int main() {
            for(int i = 0 ; i <''' +str(seq_length) + '''; i++){
                '''+seq_name+'''(i);
            }
        }
        '''
    
    return check_generated_code(thread_id, seq_values, runner_code)
    

