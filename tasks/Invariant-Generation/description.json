{
    "preprocessing" : ["", "python3 preprocess.py {}"],
    "llms" : ["gwen-coder", "code-llama", "etc."],
    "prompts" : 
    {
        "translation": "translation",
        "repair_compilererror": "",
        "repair_translationerror": ""
    },
    "specifications" : 
    {
        "input" : "",
        "output" : "===== BEGIN ACSL GUIDE =====
Chapter 2: A First ACSL Example

The most important ACSL concept is the function contract. A function contract for a C function f is a set of requirements over the arguments of f and/or a set of properties that are ensured at the end of the function. The formula that expresses the requirements is called a pre-condition, whereas the formula that expresses the properties ensured when f returns is a post-condition.

Let us consider the example of the max function. Informally, its specification can be expressed this way: the function max takes two int as arguments, and returns the greatest one. Let us see how this can be expressed in ACSL:

/*@
  ensures \result >= x && \result >= y;
  ensures \result == x || \result == y;
*/
int max (int x, int y) {
  return (x > y) ? x : y;
}

As can be seen above, ACSL annotations are written in special C comments, the difference with plain comments being that annotations begin with '/*@'. It is also possible to write one-line annotations introduced by '//@'. The function contract is written immediately above the function declaration. In this example, the contract contains only post-conditions (ensures clauses), as max does not have any particular requirement.


Chapter 3: Pointers

3.1 A First Specification

Let us now consider a small program involving pointers. Informally, the max_ptr function takes two pointers as argument, and if necessary swaps the two pointed values so that the value stored in the first pointer is the minimal one and the value stored in the second pointer is the maximal one. A specification can be the following:

/*@
  requires \valid(p) && \valid(q);
  ensures *p<=*q;
*/
void max_ptr(int* p, int* q);

Here, we have a pre-condition (the requires clause). Namely, we want our function to be called with valid pointers as arguments. This is what the built-in ACSL predicate \valid says. Note that \valid takes into account the static type of its argument: in our context, \valid(p) indicates that there address p is included in an allocated block which is large enough to store an int starting at p. This is thus different from \valid((char *)p) for instance.

3.2 Building a Complete Specification

The implementation seen in the previous section is correct with respect to the specification of max_ptr. Unfortunately, this is not the only conforming implementation: the specification is only partial, and is for instance met by the following function:

void max_ptr(int* p, int* q) {
  *p = *q = 0;
}

We may want to refine our specification to avoid an implementation such as above. Namely, we want to enforce a relation between the values pointed to by p and q at the beginning and at the end of the function. A possible specification is then

/*@
  requires \valid(p) && \valid(q);
  ensures *p <= *q;
  ensures (*p == \old(*p) && *q == \old(*q)) || (*p == \old(*q) && *q == \old(*p));
*/
void max_ptr(int* p, int* q);

The \old built-in function says that its argument must be evaluated in the pre-state (i.e. at the beginning) of the
function.

3.3 Memory location Separation

Pointers introduce the potential issue of aliasing, where multiple pointers can reference the same memory location. While this is harmless in some functions, it can become problematic in others. To guarantee that pointers refer to distinct memory locations, ACSL offers the predicate \separated(p1, ..., pn). This predicate takes a set of pointers as parameters and evaluates to true if, and only if, these pointers do not overlap.


Chapter 4: Behaviors

The second ensures clause of our final specification of max_ptr is a bit complicated, and does not explain immediately in which case we will end up. It is possible to express that differently, by using ACSL's behaviors. A function can have several behaviors in addition to a general specification. A behavior can have additional ensures clauses, but in addition, it can also have assumes clauses, which indicate when the behavior is triggered. There is no requirement for the behaviors to cover all contexts in which a function can be called, and behaviors need not to cover disjoint cases. This can be further specified by the complete behaviors and disjoint behaviors clauses, as in the following specification.

/*@
  requires \valid(p) && \valid(q);
  ensures *p <= *q;
  behavior p_minimum:
    assumes *p < *q;
    ensures *p == \old(*p) && *q == \old(*q);
  behavior q_minimum:
    assumes *p >= *q;
    ensures *p == \old(*q) && *q == \old(*p);
  complete behaviors p_minimum, q_minimum;
  disjoint behaviors p_minimum, q_minimum;
*/
void max_ptr(int* p, int* q);


Chapter 5: Arrays

5.1 Basic Specification

Now that we have specified a max_ptr function, we can use it to extract the maximal value found in a sequence of ints. A first step is to write the prototype of the corresponding function with its specification.

/*@
  requires n > 0;
  requires \valid(p+ (0..n-1));
  ensures \forall int i; 0 <= i <= n-1 ==> \result >= p[i];
  ensures \exists int e; 0 <= e <= n-1 && \result == p[e];
*/
int max_seq(int* p, int n);


Chapter 6: Assigns clauses

As with the initial specification of max_ptr, an implementation of max_seq could zero all the locations p[0],p[1],. . . ,p[n-1], return zero, and would still satisfy the post-conditions in the specification from section 5.1. Again, we can use the \old keyword to avoid that.

/*@
  requires n > 0;
  requires \valid(p+ (0..n-1));
  ensures \forall int i; 0 <= i <= n-1 ==> p[i] == \old(p[i]);
  ensures \forall int i; 0 <= i <= n-1 ==> \result >= p[i];
  ensures \exists int e; 0 <= e <= n-1 && \result == p[e];
*/
int max_seq(int* p, int n);

It would be possible, but tedious, to use the same approach to specify that global variables do not change during the execution of max_seq. The ACSL language provides a special clause to specify that a function is not allowed to change memory locations other than the ones explicitly listed. This clause is the assigns clause, and it is part of the function contract. When no assigns clauses are specified, the function is allowed to modify every visible variable. In presence of such clauses, the function can only modify the content of the locations that are explicitly mentioned in these clauses. In our case, we do not expect max_seq to have any visible side-effect, so that the contract becomes:

/*@
  requires n > 0;
  requires \valid(p+ (0..n-1));
  assigns \nothing;
  ensures \forall int i; 0 <= i <= n-1 ==> \result >= p[i];
  ensures \exists int e; 0 <= e <= n-1 && \result == p[e];
*/
int max_seq(int* p, int n);


Chapter 7: Termination

There is yet another property that is implicitly expected from a satisfactory implementation of max_seq. Namely, this function, when called with arguments that satisfy its pre-conditions, should eventually terminate (and return a result that satisfies its post-conditions).

The termination of the function is a separate property that can be specified in its contract using the terminates clause. Because, in practice, many functions are implicitly expected to terminate, the default in ACSL is to expect functions to terminate in all the contexts that satisfy their pre-conditions. It is possible to relax a particular function's specification by providing a formula that describes the conditions in which the function is guaranteed to terminate. An implementation is then allowed not to terminate when it is called in contexts that do not satisfy this condition.

In the following example, the function f can be called with any argument c, but the function is not guaranteed to terminate if c<=0.

/*@
  assigns \nothing;
  terminates c>0;
*/
void f (int c) {
  while (!c) {
  }
  return;
}


Chapter 10: Verification Activities

10.1 Assertions

The simplest form of code annotation is an assertion. An assertion is a property that must be verified each time the execution reaches a given program point. Some assertions may be discharged directly by one analyzer or another. When this happens, it means that the analyzer has concluded that there was no possibility of the assertion not being respected when the arguments satisfy the function's pre-conditions. Conversely, when the analyzer is not able to determine that an assertion always holds, it may be able to produce a pre-condition for the function that would, if it was added to the function's contract, ensure that the assertion was verified.

In the following example, the first assertion can be verified automatically by many analyzers, whereas the second one can't. An analyzer may suggest to add the pre-condition n > 0 to f's contract.

/*@
  requires n >= 0 && n < 100;
*/
int f(int n) {
  int tmp = 100 - n;
  //@ assert tmp > 0;
  //@ assert tmp < 100;
  return tmp;
}

10.2 Loop Invariants

Another kind of code annotations is dedicated to the analysis of loops. The treatment of loops is a difficult part of static analysis, and many analyzers need to be provided with hints in the form of an invariant for each loop. A loop invariant can be seen as a special case of assertion, which is preserved across the loop body. If we look back to the max_seq function, a useful invariant for proving that the implementation satisfies the formal specification would be that res contains the maximal value seen so far.

Let us now try to formalize this invariant property. Part of the formal invariant that we are trying to build is that at any iteration j, the variable res is greater or equal to p[0],p[1],. . . ,p[j]. This part of the invariant is written:

int max_seq(int* p, int n) {
  int res = *p;
  /*@
    loop invariant \forall integer j; 0 <= j < i ==> res >= *(\at(p,Pre)+j);
  */
  for (int i = 0; i < n; i++) {
    if (res < *p) {
      res = *p;
    }
    p++;
  }
  return res;
}

We use here the \at() construct, which is a generalization of \old. Namely, it says that its argument must be evaluated in a given state of the program.

The other part of the invariant property that should be expressed formally is that there exists an element in p[0],p[1],. . . ,p[n-1] that is equal to res. In other words, this second part expresses that there exists an integer e such that 0 <= e < n and p[e] == res. In order to prove the existence of such an integer e, the simplest way is to keep track of the index for which the maximal value is attained. This can be done in ACSL with extra statements called ghost code. Ghost code is C code written inside //@ ghost .. or /*@ ghost .. */
comments. The original program must have exactly the same behavior with and without ghost code. In other words, ghost code must not interfere with the concrete implementation. The variables defined and assigned in ghost code (ghost variables) can be used in the ACSL properties. The complete annotated function max_seq then becomes:

int max_seq(int* p, int n) {
  int res = *p;
  //@ ghost int e = 0;
  /*@
    loop invariant \forall integer j; 0 <= j < i ==> res >= \at(p[j],Pre);
    loop invariant \valid(\at(p,Pre)+e) && \at(p,Pre)[e] == res;
    loop invariant 0<=i<=n;
    loop invariant p==\at(p,Pre)+i;
    loop invariant 0<=e<n;
  */
  for (int i = 0; i < n; i++) {
    if (res < *p) {
      res = *p;
      //@ ghost e = i;
    }
    p++;
  }
  return res;
}


Appendix: ACSL builtin mathematical functions

ACSL contains several mathematical builtin functions. The functions listed here are valid builtin mathematical functions.

(real) x: for the conversion from integers to reals. Constants, including float and double literals, are exactly converted to rationals. This operation is also declared to be injective.
\ceil(x), \floor(x) for the conversion from reals to integers. Constants (rationals) are truncated towards the expected direction.
\abs(x) for both integers and reals.
\sqrt(x) is declared to be injective, monotonically increasing
\exp(x), \log(x) and \log10(x) are declared to be injective, monotonically increasing.
\pow(x,n) with \pow(x,0) = 1 and \pow(x,1) = x
\sin(x), \cos(x), \tan(x), \asin(x), \acos(x), \atan(x), \sinh(x), \cosh(x), \tanh(x), \atan2(x,y), and \hypot(x,y)

===== END ACSL GUIDE ====="
    },
    "oracle" : "python3 verify.py {}",
    "evaluate" : "python3 benchmark.py"
}